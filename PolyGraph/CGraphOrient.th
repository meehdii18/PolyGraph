#pragma once
#include "CGraphOrient.h"

/******************************************************
* GPOAjouterSommet
*******************************************************
* Entrée : sIdentifiant l'identifiant du sommet à créer
* Nécessite : Rien
* Sortie : Rien
* Entraîne : La création d'un sommet d'identifiant
* sIdentifiant, puis l'ajout de ce sommet dans
* vGPOListeSommets.
******************************************************/
template<class TArc, class TSommet>
inline void PGraphOrient<TArc, TSommet>::GPOAjouterSommet(const string& sIdentifiant)
{
	if (GPOTrouverSommet(sIdentifiant) == nullptr)
	{
		TSommet* SMTNouveau = new TSommet(sIdentifiant);

		vGPOListeSommets.push_back(SMTNouveau);
	}
	else
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "Le sommet d'identifiant ";
		ssMessageErreur << sIdentifiant.c_str();
		ssMessageErreur << " existe déjà dans le graphe et n'a donc pas été ajouté.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}	
}

/******************************************************
* GPOSupprimerSommet
*******************************************************
* Entrée : sIdentifiant l'identifiant du sommet à
* supprimer
* Nécessite : Rien
* Sortie : Rien
* Entraîne : La suppression du sommet d'identifiant
* sIdentifiant du graphe
******************************************************/
template<class TArc, class TSommet>
inline void PGraphOrient<TArc, TSommet>::GPOSupprimerSommet(const string& sIdentifiant)
{
	TSommet* SMTAncienSommet = GPOTrouverSommet(sIdentifiant);

	if (SMTAncienSommet == nullptr)
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "Le sommet d'identifiant "; 
		ssMessageErreur << sIdentifiant.c_str();
		ssMessageErreur << " n'existe pas dans le graphe et n'a donc pas été supprimé.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}
	else
	{
		vGPOListeArcs.erase(remove_if(vGPOListeArcs.begin(),
			vGPOListeArcs.end(),
			[](TArc* ARCElement) {return ARCElement->ARCLireOrigine() == sIdentifiant or ARCElement->ARCLireDestination() == sIdentifiant; }));
		
		vGPOListeSommets.erase(remove_if(vGPOListeSommets.begin(),
			vGPOListeSommets.end(),
			[](TSommet* SMTElement) {return SMTElement->SMTLireIdentifiant == sIdentifiant; }));

		delete SMTAncienSommet;
		
		// supprimer le sommet de la liste de sommets du graphe
		// puis delete le sommet
		// C'est censé faire ça, à tester !!!
	}
}

/******************************************************
* GPOTrouverSommet
*******************************************************
* Entrée : sIdentifiant l'identifiant du sommet cherché
* Nécessite : Rien
* Sortie : Un pointeur vers le sommet si il est dans le
* graphe, nullptr sinon
* Entraîne : Rien
******************************************************/
template<class TArc, class TSommet>
inline TSommet* PGraphOrient<TArc, TSommet>::GPOTrouverSommet(const string& sIdentifiant)
{
	vector<TSommet*> vSMTListeSommets = GPOLireListeSommets();
	unsigned int uiBoucle = 0; 
	unsigned int uiCritereArret = vSMTListeSommets.size();

	while (uiBoucle < uiCritereArret)
	{
		if (vSMTListeSommets[uiBoucle]->SMTLireIdentifiant() == sIdentifiant)
		{
			return vSMTListeSommets[uiBoucle];
		}
		uiBoucle++;
	}
	return nullptr;
}

/******************************************************
* GPOAjouterArc
*******************************************************
* Entrée : sOrigine et sDestination l'origine et la
* destination de l'arc à créer
* Nécessite : Rien
* Sortie : Rien
* Entraîne : La création d'un arc reliant les sommets
* d'origine et de destination, si ceux-si existent et
* si l'arc n'existe pas.
******************************************************/
template<class TArc, class TSommet>
inline void PGraphOrient<TArc, TSommet>::GPOAjouterArc(const string& sOrigine, const string& sDestination)
{
	TSommet* SMTOrigine = GPOTrouverSommet(sOrigine);
	TSommet* SMTDestination = GPOTrouverSommet(sDestination);

	if (SMTOrigine == nullptr)
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "Le sommet ";
		ssMessageErreur << sOrigine.c_str();
		ssMessageErreur << " n'existe pas dans le graphe et ne peut donc pas servir d'origine.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}
	if (SMTDestination == nullptr)
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "Le sommet ";
		ssMessageErreur << sDestination.c_str();
		ssMessageErreur << " n'existe pas dans le graphe et ne peut donc pas servir de destination.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}
	if (GPOTrouverArc(sOrigine, sDestination) != nullptr)
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "L'arc d'origine ";
		ssMessageErreur << sOrigine.c_str();
		ssMessageErreur << " et de destination ";
		ssMessageErreur << sDestination.c_str();
		ssMessageErreur << " existe déjà dans le graphe et n'a donc pas été ajouté.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}
	else
	{
		TArc* ARCNouveau = new TArc(sOrigine, sDestination);

		SMTOrigine->SMTAjouterArcSortant(ARCNouveau);

		SMTDestination->SMTAjouterArcEntrant(ARCNouveau);

		vGPOListeArcs.push_back(ARCNouveau);
	}
}

/******************************************************
	* GPOSupprimerArc
	*******************************************************
	* Entrée : sOrigine et sDestination l'origine et la
	* destination de l'arc cà supprimer
	* Nécessite : Rien
	* Sortie : Rien
	* Entraîne : La suppression de l'arc reliant les
	* sommets d'origine et de destination
	******************************************************/
template<class TArc, class TSommet>
inline void PGraphOrient<TArc, TSommet>::GPOSupprimerArc(const string& sOrigine, const string& sDestination)
{
	TArc* ARCAncienArc = GPOTrouverArc(sOrigine, sDestination);
	TSommet* SMTOrigine = GPOTrouverSommet(sOrigine);
	TSommet* SMTDestination = GPOTrouverSommet(sDestination);

	if (ARCAncienArc == nullptr)
	{
		ostringstream ssMessageErreur;

		ssMessageErreur << "L'arc d'origine ";
		ssMessageErreur << sOrigine.c_str();
		ssMessageErreur << " et de destination ";
		ssMessageErreur << sDestination.c_str();
		ssMessageErreur << " n'existe pas dans le graphe et n'a donc pas été supprimé.";

		string sDescription = ssMessageErreur.str();

		throw logic_error(sDescription);
	}
	else
	{
		SMTOrigine->SMTSupprimerArcSortant(ARCAncienArc);

		SMTDestination->SMTSupprimerArcEntrant(ARCAncienArc);

		vGPOListeArcs.erase(remove_if(vGPOListeArcs.begin(),
			vGPOListeArcs.end(),
			[](TArc* ARCElement) {return ARCElement->ARCLireOrigine() == sOrigine and ARCElement->ARCLireDestination() == sDestination; }));
	}
}

/******************************************************
* GPOTrouverArc
*******************************************************
* Entrée : sOrigine et sDestination l'origine et la
* destination de l'arc cherché
* Nécessite : Rien
* Sortie : Un pointeur vers le'arc si il est dans le
* graphe, nullptr sinon
* Entraîne : Rien
******************************************************/
template<class TArc, class TSommet>
inline TArc* PGraphOrient<TArc, TSommet>::GPOTrouverArc(const string& sOrigine, const string& sDestination)
{
	vector<TArc*> vARCListeArcs = GPOLireListeArcs();
	unsigned int uiBoucle = 0;
	unsigned int uiCritereArret = vARCListeArcs.size();

	while (uiBoucle < uiCritereArret)
	{
		if (vARCListeArcs[uiBoucle]->ARCLireOrigine() == sOrigine and vARCListeArcs[uiBoucle]->ARCLireDestination() == sDestination)
		{
			return vARCListeArcs[uiBoucle];
		}
		uiBoucle++;
	}
	return nullptr;
}
